<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Two-Party Private-Token XOR Toy</title>
<style>
  body{font-family:system-ui,Segoe UI,Roboto,Arial;max-width:900px;margin:20px auto;padding:0 16px;color:#111}
  h1{font-size:20px;margin-bottom:6px}
  .cols{display:grid;grid-template-columns:1fr 1fr;gap:12px}
  label{display:block;margin-top:8px;font-size:13px}
  input[type=text]{width:100%;padding:8px;font-size:13px}
  button{padding:8px 10px;margin-top:8px}
  pre{background:#f7f7f7;padding:10px;border-radius:6px;overflow:auto}
  .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace}
  small{color:#555}
  .secret{background:#fff4e6;border:1px dashed #e6b27a;padding:8px;border-radius:6px}
</style>
</head>
<body>
  <h1>Two-Party XOR (Private tokens per party)</h1>
  <p>This generator produces a public <strong>Starting Value S</strong> and two <em>private</em> tokens (for A and B). Deliver the private tokens to each party separately — do not embed them in the public S.</p>

  <h2>1) Enter target final T (exactly 10 ASCII characters)</h2>
  <input id="targetInput" type="text" maxlength="10" placeholder="ABCDEFGHIJ" />
  <div>
    <button id="genBtn">Generate S & private tokens</button>
    <small> (private tokens must be delivered privately to each party)</small>
  </div>

  <h3>Output (copy these)</h3>
  <div class="cols">
    <div>
      <label>Public Starting Value S (give this to everyone)</label>
      <pre id="startVal" class="mono"></pre>
      <small>Printable token ~14 chars (give publicly).</small>
    </div>

    <div>
      <label>Private token for Party A (give only to A)</label>
      <div class="secret"><pre id="tokenA" class="mono"></pre>
      <button id="revealA">Reveal A token</button></div>
      <small>Do not show this to Party B or others.</small>

      <label style="margin-top:10px">Private token for Party B (give only to B)</label>
      <div class="secret"><pre id="tokenB" class="mono"></pre>
      <button id="revealB">Reveal B token</button></div>
      <small>Do not show this to Party A or others.</small>
    </div>
  </div>

  <hr/>

  <h2>2) Party A: apply boolean and send message to B</h2>
  <label>Paste public Starting Value S (you received this publicly)</label>
  <input id="a_s_input" type="text" />
  <label>Paste your Private Token (A)</label>
  <input id="a_token_input" type="text" />
  <label>A's boolean</label>
  <select id="a_bool"><option value="true">true</option><option value="false">false</option></select>
  <div><button id="a_apply">Apply → produce message to send to B</button></div>
  <label>Message to send to B</label>
  <pre id="msgToB" class="mono"></pre>

  <hr/>

  <h2>3) Party B: apply boolean to message and get final</h2>
  <label>Paste message received from A</label>
  <input id="b_msg_input" type="text" />
  <label>Paste your Private Token (B)</label>
  <input id="b_token_input" type="text" />
  <label>B's boolean</label>
  <select id="b_bool"><option value="true">true</option><option value="false">false</option></select>
  <div><button id="b_apply">Apply → produce final</button></div>
  <label>Final output (Base64URL and ASCII if printable)</label>
  <pre id="finalOut" class="mono"></pre>

  <h3>Important notes</h3>
  <ul>
    <li><strong>Private tokens must be delivered privately</strong> to each respective party (A gets only A's token; B gets only B's token). The public S can be given to anyone.</li>
    <li>Internally this uses XOR on 10 bytes. The generator computed S = T ⊕ A_true ⊕ B_true so that when both choose <code>true</code> the final equals T.</li>
    <li>This is a toy: do not use for real secrets without expert review. If an attacker obtains a party's private token they can alter outcomes.</li>
  </ul>

<script>
/* base64url helpers */
function toBase64Url(bytes){
  let binary = "";
  const chunk = 0x8000;
  for (let i=0; i<bytes.length; i+=chunk){
    binary += String.fromCharCode.apply(null, bytes.subarray(i, i+chunk));
  }
  let b64 = btoa(binary);
  return b64.replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');
}
function fromBase64Url(s){
  s = s.replace(/-/g,'+').replace(/_/g,'/');
  while (s.length % 4) s += '=';
  const binary = atob(s);
  const bytes = new Uint8Array(binary.length);
  for (let i=0;i<binary.length;i++) bytes[i]=binary.charCodeAt(i);
  return bytes;
}
function xorBytes(a,b){
  const out = new Uint8Array(a.length);
  for (let i=0;i<a.length;i++) out[i] = a[i] ^ b[i];
  return out;
}
function asciiToBytes(s){ return new TextEncoder().encode(s); }
function bytesToAsciiTry(bytes){
  try{ return new TextDecoder().decode(bytes); }catch(e){ return null; }
}
function randN(n){ const a=new Uint8Array(n); crypto.getRandomValues(a); return a; }

/* Elements */
const startPre = document.getElementById('startVal');
const tokenApre = document.getElementById('tokenA');
const tokenBpre = document.getElementById('tokenB');
const revealA = document.getElementById('revealA');
const revealB = document.getElementById('revealB');

let A_token_obj = null;
let B_token_obj = null;
let S_bytes = null;
let T_str = null;

/* Generate: create four masks (A_true, A_false, B_true, B_false).
   Compute S = T ⊕ A_true ⊕ B_true. Keep tokens private. */
document.getElementById('genBtn').addEventListener('click', ()=>{
  const t = document.getElementById('targetInput').value;
  if (!t || t.length !== 10){ alert('Enter exactly 10 ASCII characters for T.'); return; }
  T_str = t;
  // generate masks
  const A_true = randN(10), A_false = randN(10);
  const B_true = randN(10), B_false = randN(10);

  // compute S = T ⊕ A_true ⊕ B_true
  const Tbytes = asciiToBytes(T_str);
  let tmp = xorBytes(Tbytes, A_true);
  S_bytes = xorBytes(tmp, B_true);

  // Public S (Base64URL)
  startPre.textContent = toBase64Url(S_bytes);

  // Private tokens: we will encode the pair of masks for each party as a small JSON object,
  // then base64url-encode it so it can be copied/pasted easily.
  A_token_obj = { role:'A', true: toBase64Url(A_true), false: toBase64Url(A_false) };
  B_token_obj = { role:'B', true: toBase64Url(B_true), false: toBase64Url(B_false) };

  // For safety, do NOT auto-show tokens. Show placeholders; reveal on explicit button click.
  tokenApre.textContent = 'TOKEN NOT REVEALED — click "Reveal A token" (copy & deliver privately)';
  tokenBpre.textContent = 'TOKEN NOT REVEALED — click "Reveal B token" (copy & deliver privately)';
});

/* Reveal functions — reveal only on explicit click so generator consciously copies tokens out-of-band */
revealA.addEventListener('click', ()=>{
  if (!A_token_obj){ alert('Generate first.'); return; }
  tokenApre.textContent = JSON.stringify(A_token_obj);
});
revealB.addEventListener('click', ()=>{
  if (!B_token_obj){ alert('Generate first.'); return; }
  tokenBpre.textContent = JSON.stringify(B_token_obj);
});

/* Party A: apply */
document.getElementById('a_apply').addEventListener('click', ()=>{
  const s_in = document.getElementById('a_s_input').value.trim();
  const token_in = document.getElementById('a_token_input').value.trim();
  if (!s_in || !token_in){ alert('Paste public S and your private token A.'); return; }
  let sbytes;
  try{ sbytes = fromBase64Url(s_in); } catch(e){ alert('Invalid S encoding'); return; }
  if (sbytes.length !== 10){ alert('S must encode 10 bytes'); return; }

  // parse token (we expect generator to have given JSON like {"role":"A","true":"...","false":"..."} )
  let tok;
  try{ tok = JSON.parse(token_in); } catch(e){ alert('Invalid token format — expected JSON (copy token exactly).'); return; }
  if (!tok.true || !tok.false){ alert('Token missing true/false masks.'); return; }
  let mask;
  try{ mask = fromBase64Url(tok[ document.getElementById('a_bool').value ]); } catch(e){ alert('Invalid mask data'); return; }
  if (mask.length !== 10){ alert('Mask length wrong.'); return; }

  const out = xorBytes(sbytes, mask);
  document.getElementById('msgToB').textContent = toBase64Url(out);
});

/* Party B: apply */
document.getElementById('b_apply').addEventListener('click', ()=>{
  const msg_in = document.getElementById('b_msg_input').value.trim();
  const token_in = document.getElementById('b_token_input').value.trim();
  if (!msg_in || !token_in){ alert('Paste message from A and your private token B.'); return; }
  let mbytes;
  try{ mbytes = fromBase64Url(msg_in); } catch(e){ alert('Invalid message encoding'); return; }
  if (mbytes.length !== 10){ alert('Message must encode 10 bytes'); return; }

  let tok;
  try{ tok = JSON.parse(token_in); } catch(e){ alert('Invalid token format — expected JSON.'); return; }
  if (!tok.true || !tok.false){ alert('Token missing true/false masks.'); return; }
  let mask;
  try{ mask = fromBase64Url(tok[ document.getElementById('b_bool').value ]); } catch(e){ alert('Invalid mask data'); return; }
  if (mask.length !== 10){ alert('Mask length wrong.'); return; }

  const final = xorBytes(mbytes, mask);
  const b64 = toBase64Url(final);
  let ascii = bytesToAsciiTry(final);
  let outText = b64 + '\\n';
  if (ascii && ascii.length === 10 && /^[\\x20-\\x7E]*$/.test(ascii)) outText += 'ASCII: ' + ascii;
  else outText += 'ASCII: (not printable)';
  // If generator used this page and T is known locally, optionally check match:
  if (T_str){
    const Tbytes = asciiToBytes(T_str || '');
    const equal = final.length === Tbytes.length && final.every((v,i)=>v === Tbytes[i]);
    outText += '\\n\\nMatches target T? ' + (equal ? 'YES' : 'NO');
  }
  document.getElementById('finalOut').textContent = outText;
});
</script>
</body>
</html>
